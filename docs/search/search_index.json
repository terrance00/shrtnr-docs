{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to shrtnr.io This site serves as the main center of documentation and architecture for shrtnr.io. What is shrtnr.io? In short , a URL shortening service geared towards helping you share your content in as little space as possible. Convert https://www.google.com/ads/a-very-very-very-long-url-with-parameters?id=12345&param1=a_long_parameters&param2=a_very_long_parameter Into https://shrtnr.io/a0A","title":"Introduction"},{"location":"#introduction-to-shrtnrio","text":"This site serves as the main center of documentation and architecture for shrtnr.io.","title":"Introduction to shrtnr.io"},{"location":"#what-is-shrtnrio","text":"In short , a URL shortening service geared towards helping you share your content in as little space as possible. Convert https://www.google.com/ads/a-very-very-very-long-url-with-parameters?id=12345&param1=a_long_parameters&param2=a_very_long_parameter Into https://shrtnr.io/a0A","title":"What is shrtnr.io?"},{"location":"architectural-overview/","text":"Architectural Overview Services shrtnr-api shrtnr-oidc shrtnr-analytics shrtnr-ui shrtnr-redirector System In short, the entire system will be deployed as a Kubernetes cluster (AKS), with load balancers for the public facing services. Our applications and services will be packaged as Docker images. In addition to the k8s system, we will have two data-stores. MongoDB backing the redirector as a horizontally scalable document store. Postgres backing the API and OIDC service as a relational store. Additional infrastructure includes a RabbitMQ instance for queueing up analytics data to be consumed by the analytics service. Diagram graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; Flows User shortening a URL: graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!]; User following a shortened link: graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!];","title":"Architectural Overview"},{"location":"architectural-overview/#architectural-overview","text":"","title":"Architectural Overview"},{"location":"architectural-overview/#services","text":"shrtnr-api shrtnr-oidc shrtnr-analytics shrtnr-ui shrtnr-redirector","title":"Services"},{"location":"architectural-overview/#system","text":"In short, the entire system will be deployed as a Kubernetes cluster (AKS), with load balancers for the public facing services. Our applications and services will be packaged as Docker images. In addition to the k8s system, we will have two data-stores. MongoDB backing the redirector as a horizontally scalable document store. Postgres backing the API and OIDC service as a relational store. Additional infrastructure includes a RabbitMQ instance for queueing up analytics data to be consumed by the analytics service.","title":"System"},{"location":"architectural-overview/#diagram","text":"graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!];","title":"Diagram"},{"location":"architectural-overview/#flows","text":"","title":"Flows"},{"location":"architectural-overview/#user-shortening-a-url","text":"graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!];","title":"User shortening a URL:"},{"location":"architectural-overview/#user-following-a-shortened-link","text":"graph LR A[Start] --> B{Error?}; B -->|Yes| C[Hmm...]; C --> D[Debug]; D --> B; B ---->|No| E[Yay!];","title":"User following a shortened link:"},{"location":"ci-cd/automation/","text":"Automation Service containerization Every service will have a docker file and upon successfull PR will be compiled and packaged into a docker container. The container registry of choice should be hosted on the relevant cloud server - Azure container registry (ACR) for our purposes. These will be versioned according to the versioning strategy below Deployments A k8s manifest will exist within a repo, for development and master branches. Deployments will occur automatically from these manifests. In addition all logic for deploying and maintaining load balancers and external data services will exist as deployment scripts on this repo in the form of Azure pipelines . Versioning Semantic versioning wil be used. That is to say x.y.z where x is the major version (used for breaking changes), y is the feature version (used for new features) and z is the bug version, used for any hotfix or bug. For the development environment , all merged PR's will be built and deployed as the next version (AKA x.y.x+1-{build-number} ) with the build number appended. With the build number appened all deployed versions will be easy to track back to a commit hash.","title":"Automation"},{"location":"ci-cd/automation/#automation","text":"","title":"Automation"},{"location":"ci-cd/automation/#service-containerization","text":"Every service will have a docker file and upon successfull PR will be compiled and packaged into a docker container. The container registry of choice should be hosted on the relevant cloud server - Azure container registry (ACR) for our purposes. These will be versioned according to the versioning strategy below","title":"Service containerization"},{"location":"ci-cd/automation/#deployments","text":"A k8s manifest will exist within a repo, for development and master branches. Deployments will occur automatically from these manifests. In addition all logic for deploying and maintaining load balancers and external data services will exist as deployment scripts on this repo in the form of Azure pipelines .","title":"Deployments"},{"location":"ci-cd/automation/#versioning","text":"Semantic versioning wil be used. That is to say x.y.z where x is the major version (used for breaking changes), y is the feature version (used for new features) and z is the bug version, used for any hotfix or bug. For the development environment , all merged PR's will be built and deployed as the next version (AKA x.y.x+1-{build-number} ) with the build number appended. With the build number appened all deployed versions will be easy to track back to a commit hash.","title":"Versioning"},{"location":"ci-cd/branching-strategy/","text":"Branching Strategy Git flow (modified) A simpler version of git flow will be used for the code branching strategy. Two main branches will exists: master All official releases will be built from this branch and tagged on the git repo in azure. This branch will have strict rules to complete a pull request to and will require extensive QA analysis. development The development branch will be the running branch all features go into. This branch will become the pre-release branch and this is where QA will perform testing. Before Releasing pre-release This is essentially the QA branch. Tests will be run on this branch and upon release, will be merged to master. Features feature/XXX Features will live in feature branches. In a sprint features that aren't planned to be released to master should stay in feature branches until it is slated for release. Once slated for release feature branches will be reviewed and merged into development.","title":"Branching Strategy"},{"location":"ci-cd/branching-strategy/#branching-strategy","text":"","title":"Branching Strategy"},{"location":"ci-cd/branching-strategy/#git-flow-modified","text":"A simpler version of git flow will be used for the code branching strategy. Two main branches will exists: master All official releases will be built from this branch and tagged on the git repo in azure. This branch will have strict rules to complete a pull request to and will require extensive QA analysis. development The development branch will be the running branch all features go into. This branch will become the pre-release branch and this is where QA will perform testing.","title":"Git flow (modified)"},{"location":"ci-cd/branching-strategy/#before-releasing","text":"pre-release This is essentially the QA branch. Tests will be run on this branch and upon release, will be merged to master.","title":"Before Releasing"},{"location":"ci-cd/branching-strategy/#features","text":"feature/XXX Features will live in feature branches. In a sprint features that aren't planned to be released to master should stay in feature branches until it is slated for release. Once slated for release feature branches will be reviewed and merged into development.","title":"Features"},{"location":"data-stores/shrtnr-db/","text":"Shrtnr DB This will be the main relational database. This database will support the following services: OIDC This is the identity service and will keep track of user identity. this service will use OpenIddict as the identity library. Check out the docs here . Analytics This service keeps track of analytical data surrounding the redirect service.","title":"Shrtnr Db"},{"location":"data-stores/shrtnr-db/#shrtnr-db","text":"This will be the main relational database. This database will support the following services: OIDC This is the identity service and will keep track of user identity. this service will use OpenIddict as the identity library. Check out the docs here . Analytics This service keeps track of analytical data surrounding the redirect service.","title":"Shrtnr DB"},{"location":"data-stores/shrtnr-redirector-store/","text":"Shrtnr Redirector Store A very simple data store containing the indexed URL hash key and full URL. This data store will support the following service: Shrtnr Redirector Why Mongo? Mongo has a highly performant indexing capability. Mongo has the ability to use sharding to scale horizontally. Mongo as a document store is very simple to implement. Check out the docs here .","title":"Shrtnr Redirector Store"},{"location":"data-stores/shrtnr-redirector-store/#shrtnr-redirector-store","text":"A very simple data store containing the indexed URL hash key and full URL. This data store will support the following service: Shrtnr Redirector","title":"Shrtnr Redirector Store"},{"location":"data-stores/shrtnr-redirector-store/#why-mongo","text":"Mongo has a highly performant indexing capability. Mongo has the ability to use sharding to scale horizontally. Mongo as a document store is very simple to implement. Check out the docs here .","title":"Why Mongo?"},{"location":"sdlc/bugs/","text":"Bugs Pre-Release Bugs found in the pre-release phase by QA or any other process will take top priority so as not to delay the planned release. Hotfixes Bugs that are absolutely critical will be fixed, tested and released immediately. Bugs into test cases Bugs that are found by QA or in production will automatically be slated to form part of the collection of test cases. Ideally we would want these test cases to be tested automatically, however at the very least they will be covered by regression tests.","title":"Bugs"},{"location":"sdlc/bugs/#bugs","text":"","title":"Bugs"},{"location":"sdlc/bugs/#pre-release","text":"Bugs found in the pre-release phase by QA or any other process will take top priority so as not to delay the planned release.","title":"Pre-Release"},{"location":"sdlc/bugs/#hotfixes","text":"Bugs that are absolutely critical will be fixed, tested and released immediately.","title":"Hotfixes"},{"location":"sdlc/bugs/#bugs-into-test-cases","text":"Bugs that are found by QA or in production will automatically be slated to form part of the collection of test cases. Ideally we would want these test cases to be tested automatically, however at the very least they will be covered by regression tests.","title":"Bugs into test cases"},{"location":"sdlc/pull-requests/","text":"Pull Requests Rules Before pull requests will be eligible for review, a certain amount of processes will be ran: PR branches will be compiled and must compile succesfully. PR branches' unit tests will be run and must comile successfully. At some point, we might include automation testing for the UI using something like Cypress . PR's will need to reviewed by atleast two peers. Strict rules will apply for spelling and formatting - PR's with these errors will be declined. Any change to the PR branch will result in the above rules and processes running again.","title":"Pull Requests"},{"location":"sdlc/pull-requests/#pull-requests","text":"","title":"Pull Requests"},{"location":"sdlc/pull-requests/#rules","text":"Before pull requests will be eligible for review, a certain amount of processes will be ran: PR branches will be compiled and must compile succesfully. PR branches' unit tests will be run and must comile successfully. At some point, we might include automation testing for the UI using something like Cypress . PR's will need to reviewed by atleast two peers. Strict rules will apply for spelling and formatting - PR's with these errors will be declined. Any change to the PR branch will result in the above rules and processes running again.","title":"Rules"},{"location":"sdlc/qa/","text":"QA Cycle Essentially by the time a sprint is completed. All features should be merged in to the development branch. By the start of the QA cycle a deployed version of the system will exist based on the pre-release branch. The QA cycle will commence after the previous sprint has completed. The release will be slated one sprint behind the previous sprint. Test Cases Test cases should be documented and form part of a regression cycle. The regression cycle should be run for every release. It would be a massive win if the regression test cases can systematically be automated to relieve the QA team.","title":"QA"},{"location":"sdlc/qa/#qa","text":"","title":"QA"},{"location":"sdlc/qa/#cycle","text":"Essentially by the time a sprint is completed. All features should be merged in to the development branch. By the start of the QA cycle a deployed version of the system will exist based on the pre-release branch. The QA cycle will commence after the previous sprint has completed. The release will be slated one sprint behind the previous sprint.","title":"Cycle"},{"location":"sdlc/qa/#test-cases","text":"Test cases should be documented and form part of a regression cycle. The regression cycle should be run for every release. It would be a massive win if the regression test cases can systematically be automated to relieve the QA team.","title":"Test Cases"},{"location":"sdlc/release-cycle/","text":"Release Cycle New versions will be released a sprint behind - allowing them to go through a QA cycle. The new version will be decided based on the semantic versioning principle: X.Y.Z For a new feature (non-breaking), the Y number will be incremented. For bugfixes only, the Z number will be incremented. The major version X will only be updated upon making a breaking change. Rollbacks To design a good microservices system, one needs to strive to make all the services stateless. With the above principle in mind, rolling back service versions should be as simple as updating the k8s manifest file. Backups Services that aren't stateless by definition. Like databases, queues and caching services should be backed up before doing any releases.","title":"Release Cycle"},{"location":"sdlc/release-cycle/#release-cycle","text":"New versions will be released a sprint behind - allowing them to go through a QA cycle. The new version will be decided based on the semantic versioning principle: X.Y.Z For a new feature (non-breaking), the Y number will be incremented. For bugfixes only, the Z number will be incremented. The major version X will only be updated upon making a breaking change.","title":"Release Cycle"},{"location":"sdlc/release-cycle/#rollbacks","text":"To design a good microservices system, one needs to strive to make all the services stateless. With the above principle in mind, rolling back service versions should be as simple as updating the k8s manifest file.","title":"Rollbacks"},{"location":"sdlc/release-cycle/#backups","text":"Services that aren't stateless by definition. Like databases, queues and caching services should be backed up before doing any releases.","title":"Backups"},{"location":"services/shrtnr-analytics/","text":"Analytics The analytics service will provide insights and value to customers. Proposed tech This service will simply need to subscribe to a queue, ingest the data and persist it. .Net , or NodeJS will be perfectly suited to this task. Data feed The data for providing valuable insights to users of the system will be fed into a RabbitMQ instance by the redirector . The analytics service will be subsribed to the above queue and ingest the data provided. Users will be able to access this data through the UI .","title":"Shrtnr Analytics"},{"location":"services/shrtnr-analytics/#analytics","text":"The analytics service will provide insights and value to customers.","title":"Analytics"},{"location":"services/shrtnr-analytics/#proposed-tech","text":"This service will simply need to subscribe to a queue, ingest the data and persist it. .Net , or NodeJS will be perfectly suited to this task.","title":"Proposed tech"},{"location":"services/shrtnr-analytics/#data-feed","text":"The data for providing valuable insights to users of the system will be fed into a RabbitMQ instance by the redirector . The analytics service will be subsribed to the above queue and ingest the data provided. Users will be able to access this data through the UI .","title":"Data feed"},{"location":"services/shrtnr-api/","text":"Shrtnr API This API will be consumed mainly by the UI that has been created. However best practices should be kept in mind, and the API can be designed with RESTFull principles. In the event a browser extension or mobile application wants to consume this API, it will easily be able to do so. Proposed Tech A Restfull webAPI can easily be implemented by the following technologies: .Net Very simple to bootstrap. Strongly typed. Latest versions are extremely performant. NodeJS will be perfectly suited to this task. Many developers know javascript . Can have improved typing and stability by implementing typescript .","title":"API"},{"location":"services/shrtnr-api/#shrtnr-api","text":"This API will be consumed mainly by the UI that has been created. However best practices should be kept in mind, and the API can be designed with RESTFull principles. In the event a browser extension or mobile application wants to consume this API, it will easily be able to do so.","title":"Shrtnr API"},{"location":"services/shrtnr-api/#proposed-tech","text":"A Restfull webAPI can easily be implemented by the following technologies: .Net Very simple to bootstrap. Strongly typed. Latest versions are extremely performant. NodeJS will be perfectly suited to this task. Many developers know javascript . Can have improved typing and stability by implementing typescript .","title":"Proposed Tech"},{"location":"services/shrtnr-oidc/","text":"Shrtnr OIDC This server will employ the standardized OIDC protocol for managing user identity and security. Proposed Tech .Net To implement OIDC, we can use the following system: openiddict . This system will be backed by the shrtnr-db data-store - running postgres . Why OIDC OIDC specifies industry standards and best practices for managing security and identity. Openiddict , is certified by the OIDC foundation and is completely free and open source.","title":"OIDC"},{"location":"services/shrtnr-oidc/#shrtnr-oidc","text":"This server will employ the standardized OIDC protocol for managing user identity and security.","title":"Shrtnr OIDC"},{"location":"services/shrtnr-oidc/#proposed-tech","text":".Net To implement OIDC, we can use the following system: openiddict . This system will be backed by the shrtnr-db data-store - running postgres .","title":"Proposed Tech"},{"location":"services/shrtnr-oidc/#why-oidc","text":"OIDC specifies industry standards and best practices for managing security and identity. Openiddict , is certified by the OIDC foundation and is completely free and open source.","title":"Why OIDC"},{"location":"services/shrtnr-redirector/","text":"Shrtnr Redirector The redirector service will have a very simple task: Receive a request. Lookup the target URL in the index optimized mongodb database. Queue all the request context data - to be picked up by the analytics service . Redirect the user. Propsed Tech A very lightweight web application aimed at squeezing as much performance out as possible - The latest version of .Net will be ideal for this use case.","title":"Redirector"},{"location":"services/shrtnr-redirector/#shrtnr-redirector","text":"The redirector service will have a very simple task: Receive a request. Lookup the target URL in the index optimized mongodb database. Queue all the request context data - to be picked up by the analytics service . Redirect the user.","title":"Shrtnr Redirector"},{"location":"services/shrtnr-redirector/#propsed-tech","text":"A very lightweight web application aimed at squeezing as much performance out as possible - The latest version of .Net will be ideal for this use case.","title":"Propsed Tech"},{"location":"services/shrtnr-ui/","text":"Shrtnr UI The UI component of the system will be the principle method for users to interact with the system. Users will register and be authenticated by the OIDC system . From here they will be able to shorten their URLs and view analytics build from the analytics service . Propposed Tech A UX/UI designer can spec out the application. Using the modern material design paradigm comes recommended. Being a web front end the following technologies will be useful: React : Very quick to bootstrap and hit the ground running Popular framework with lots of developers Can be set up to have useful tools like tests, typescript etc. Angular : Comes full features out of the box and is ideal for enterprise scale development. Uses typescript natively and provides a lot more robust compilation safety. Has a heavier learning curve than most front-end frameworks.","title":"Shrtnr UI"},{"location":"services/shrtnr-ui/#shrtnr-ui","text":"The UI component of the system will be the principle method for users to interact with the system. Users will register and be authenticated by the OIDC system . From here they will be able to shorten their URLs and view analytics build from the analytics service .","title":"Shrtnr UI"},{"location":"services/shrtnr-ui/#propposed-tech","text":"A UX/UI designer can spec out the application. Using the modern material design paradigm comes recommended. Being a web front end the following technologies will be useful: React : Very quick to bootstrap and hit the ground running Popular framework with lots of developers Can be set up to have useful tools like tests, typescript etc. Angular : Comes full features out of the box and is ideal for enterprise scale development. Uses typescript natively and provides a lot more robust compilation safety. Has a heavier learning curve than most front-end frameworks.","title":"Propposed Tech"}]}